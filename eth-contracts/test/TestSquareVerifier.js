// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates
const Verifier = artifacts.require("Verifier");
let proof = require("../../zokrates/code/square/proof.json");
//console.log(proof);
// Test verification with correct proof
// - use the contents from proof.json generated from zokrates steps
contract("TestSquareVerifier", async (accounts) => {

    const user1 = accounts[0];
    var contractInstance;
    // console.log(user1);
    // console.log(proof);

    describe("Testing square verifier: ZK snarks", function () {
        beforeEach(async function() {
            contractInstance = await Verifier.deployed();
        });
        it("verifies with correct proof", async() => {
            //console.log(typeof(proof.proof.A_p));
            let verified = await contractInstance.verifyTx.call(
                proof.proof.A,
                proof.proof.A_p,
                proof.proof.B,
                proof.proof.B_p,
                proof.proof.C,
                proof.proof.C_p,
                proof.proof.H,
                proof.proof.K,
                proof.input
            );
            assert.equal(verified, true, "Proof could not be verified");
        });

        it("does not verify with incorrect proof", async() => {
            // let falsePair equal to the A_p property
            let falsePair = ["0x12baad06ae829ea52943352045db3763a622ec277b9cd521f4abd1d42735771a", "0x8132fae6f08fcb476ae909020bb6ad975d36b0f9ae5fe4e7eaaf488229191f8"];
            let verified = await contractInstance.verifyTx.call(
                falsePair,
                proof.proof.A_p,
                proof.proof.B,
                proof.proof.B_p,
                proof.proof.C,
                proof.proof.C_p,
                proof.proof.H,
                proof.proof.K,
                proof.input
            );
            assert.equal(verified, false, "Proof is false. It should not have been verified");
        });

    });


});
